（1）
Test a调用一次构造函数
a = 1调用一次构造函数（Test（1）），一次移动赋值运算，执行结束后调用一次析构函数（Test（1））
F(a)传参时调用一次复制构造函数
Test b = std::move(a)调用一次移动构造函数
传返回值时调用一次移动构造函数，之后调用一次析构函数（b）
Test A = F(a)调用一次移动构造函数，结束后调用两次析构函数（F（a），参数a）
main结束调用两次析构函数（A，a）
（2）
Test（1）调用一次构造函数
由于a为常量引用，std::move无法改变其属性，Test b = std::move(a)调用一次复制构造函数
传返回值时调用一次移动构造函数，之后调用一次析构函数（b）
Test A = F(1)调用一次移动构造函数，结束后调用两次析构函数（F（1），参数Test（1））
main结束调用一次析构函数（A）
（3）
Test（1）调用一次构造函数
Test b = std::move(a)调用一次移动构造函数
传返回值时调用一次移动构造函数，之后调用一次析构函数（b）
Test A = F(1)调用一次移动构造函数，结束后调用两次析构函数（F（1），参数Test（1））
main结束调用一次析构函数（A）
（4）
有编译错误，Test（1）为右值，无法传参给F（非常量左值引用需要为左值）
（5）
存在风险，F返回对临时对象Test（1）的引用
Test a调用一次构造函数
由于F传参为常量左值引用， Test b = a调用一次复制构造函数
Test（1）调用一次构造函数
const Test &A = F(std::move(a))结束，调用一次析构函数（Test（1））
F结束，调用一次析构函数（b）
main结束，调用一次析构函数（a）


